#!/bin/bash
# 2005-2006, 2009, 2014, 2015, 2016 (c) Etersoft www.etersoft.ru
# 2005-2016 Author: Vitaly Lipatov <lav@etersoft.ru>
# Public domain
#
# GS - get source
#
# Скачивает исходники, автоматически выправляя ситуацию с gz/bz2/tgz/zip (tar для git, tar.bz2 для src.rpm)
# Параметры:
# - название спек-файла
# -a - get all source
# check for the same file with other compression

# load common functions, compatible with local and installed script
. `dirname $0`/../share/eterbuild/functions/common
load_mod rpm tarball web buildsrpm

WEXT=""
GETSOURCE=""
LOADLIST="0"

#############################
Usage="Usage: $name [-a -f ] [spec] [new_version]"
function mygetopts()
{
name=${0##*/}
Descr="$name (Get Source) - get sources by spec / repository"

phelp()
{
	echog "$Descr"
	echog "$Usage"
	echog "You can run 'rpmgs 1.2' for set new version 1.2 and download it"
	echo
	echog "Options:"
	echog "   -a  get all source (not only Source|Source0)"
	echog "   -f  force download (remove source file before download)"
}

while getopts :haf opt; do
    case $opt in
    h) phelp; exit 0;;
    a) LOADLIST="$(seq 0 100)" ;;
    f) FORCEDOWNLOAD=-f ;;
    +?) echog "$name: options should not be preceded by a '+'." 1>&2; exit 2;;
    ?)  echog "$name: $OPTARG: bad option.  Use -h for help." 1>&2 ; exit 2;;
    esac
done
 
# remove args that were options
[ "$OPTIND" -gt 0 ] && shift $(($OPTIND - 1))

LISTRPMARGS=$@

}

function get_source()
{
	GETSOURCE=$(eval_spec $1 | get_var "$2")
}

repack_tarball()
{
	[ "$(realpath "$1")" = "$(realpath "$2")" ] && return
	docmd erc -f repack "$1" "$2"
}

download_any_tarball()
{
	local GETSOURCE="$1"
	local TARGET="$2"
	local FORMATS="tar.xz tar.bz2 tar.gz zip tgz 7z tbz2 tbz rar tar"
	local BASESOURCE="$GETSOURCE"

	local ORIGEXT=$(rhas "$BASESOURCE" "\." && echo "$BASESOURCE" | sed -e "s|.*\.||")
	[ -n "$ORIGEXT" ] || fatal "Have no idea how to load files without extension"

	# first try download with original extension (exclude for tar)
	if [ "$ORIGEXT" != "tar" ] ; then
		FORMATS="$ORIGEXT $(estrlist exclude "$ORIGEXT" "$FORMATS")"
	fi

	BASESOURCE=$(echo "$BASESOURCE" | sed -e "s|\.$ORIGEXT$||g")

	local ext
	# try download by exts list
	for ext in $FORMATS ; do
		[ -n "$FORCEDOWNLOAD" ] && docmd rm -f "$BASESOURCE.$ext"
		download_url "$BASESOURCE.$ext" || continue
		repack_tarball "$(basename "$BASESOURCE.$ext")" "$TARGET" || continue
		return
	done
	fatal "Cannot retrieve $GETSOURCE"
}

# param: spec name number (f.i., url for Source-url)
function source_ext()
{
	local GETSOURCEEXT=
	# %define SourceUrl ftp://updates.etersoft.ru/pub/Etersoft/WINE@Etersoft/last/sources/tarball/%name-%version.tar.gz
	#GETSOURCEURL=$(eval_spec $1 | grep -i "^%define ${2}Url${3} " | head -n 1 | sed -e "s/ *\$//g" | sed -e "s/^%define[ \t].*[ \t]//g")
	local SN="$3"
	[ "$SN" = "0" ] && SN="$SN\?"
	if grep -q "# Source$SN-$2:" "$1" ; then
		local TMPSPEC=$1.tmpurl
		local NEWSOURCE=$(grep --text "# Source$SN-$2:" "$1" | sed -e "s/.*$2:[ \t]*//g" | tail -n1)
		test -n "$NEWSOURCE" || fatal "Can't extract URL from Source$SN-$2"
		# Fake replace for correct subst variables
		NEWSOURCE="$(echo "$NEWSOURCE" | sed -e 's|\&|\\&|g')"
		# TODO: use special field before %build
		cat $1 | sed -e "s|^Summary:.*|Summary: $NEWSOURCE|g" > $TMPSPEC
		GETSOURCEEXT=$(eval_spec "$TMPSPEC" | get_var "Summary")
		rm -f "$TMPSPEC"
	fi
	
	echo "$GETSOURCEEXT"
	test -n "$GETSOURCEEXT"
}


# Source-svn: http://svn.wikimedia.org/svnroot/mediawiki/trunk/extensions/Collection/
function get_source_svn()
{
	GETSOURCESVN=$(source_ext "$1" svn "$2")
	#if [ -n "$GETSOURCESVN" ] ; then
	#	warning "Source-svn is not supported yet"
	#	( cd $SPECDIR ; git svn clone $GETSOURCESVN .)
	#fi
	#test -n "$GETSOURCESVN"
}


# Source-git: http://git.altlinux.org/people/lav/packages/rpm-build-fonts.git
function get_source_git()
{
	GETSOURCEGIT=$(source_ext "$1" git "$2")
}

# Source-url: ftp://updates.etersoft.ru/pub/Etersoft/WINE@Etersoft/last/sources/tarball/%name-%version.tar.gz
# Get real Url from comment
function get_source_url()
{
	GETSOURCEURL=$(source_ext "$1" url "$2")
}

function print_error()
{
	echog "Can't find any spec file. It is possible you run this script not in git dir."
	echog "If you use old style build, run rpmgs with spec name as arg."
	echog "If you wish download src.rpm, use rpmgp script."
	exit 1
}

# tarball dirname [options]
gear_update_from_tarball()
{
	local CREATEFLAG=-f
	local TARBALL="$1"
	local CURNAME="$2"
	shift 2
	assert_var TARBALL CURNAME
	[ -d "$CURNAME" ] || CREATEFLAG=-c
	# TODO: check tarball ext. for unsupported arch and realize it here or in gear-update
	echo "Commit tarball '$TARBALL' to git subdir '$CURNAME'..."
	if ! docmd gear-update $CREATEFLAG $@ "$TARBALL" "$CURNAME" ; then
		if gear-update $CREATEFLAG $@ "$TARBALL" "$CURNAME" 2>&1 | grep -q "More than one subdirectory specified" ; then
			echo "Try unpack as is"
			CREATEFLAG="$CREATEFLAG -a"
			docmd gear-update $CREATEFLAG $@ "$TARBALL" "$CURNAME" && return
		fi
	else
		return 0
	fi
	fatal "can't import tarball '$TARBALL'"
}

# TODO: rewrite for any tarball commit
# $nn $FTB
commit_tarball()
{
	#rhas "$GETSOURCE" "ps?://" || GETSOURCE=""
	CURNAME=$(get_tardir_from_rules) || fatal "There is no correct 'tar:' line in gear rules file, needed for commit tarball"
	# FIXME: hack to unpack to correct place.
	[ $(basename `pwd`) = ".gear" ] && cd ..
	test -d "$CURNAME" || CURNAME=$(get_tarballname "$spec")
	test -d "$CURNAME" || CURNAME=$BASENAME
	if [ -d "$RPMSOURCEDIR" ] && [ -f "$RPMSOURCEDIR/$FTB" ] ; then
		gear_update_from_tarball "$RPMSOURCEDIR/$FTB" "$CURNAME" $FORCEDOWNLOAD
		rm -f "$RPMSOURCEDIR/$FTB"
		docmd git commit -m "just import $FTB with rpmgs script"
	else
		echo "Skip missed tarball commiting"
		return 1
	fi
}

parse_cmd_pre_spec "$@"
mygetopts $LISTARGS

test -z "$VERBOSE" || echo "'$LISTNAMES' @ '$LISTRPMARGS'"

if [ -n "$LISTRPMARGS" ] ; then
	if [ -z "${LISTRPMARGS/*spec/}" ] ; then
		fatal "run with incorrect filename $LISTRPMARGS"
	fi
	if [ ! -f "$LISTNAMES" ] ; then
		fatal "set version permitted only for one file"
	fi
	if [ "${LISTRPMARGS/ /}" != "$LISTRPMARGS" ] ; then
		fatal "you run rpmgs with more than one version"
	fi
	GSSETVERSION=$LISTRPMARGS
fi

test -z "$LISTNAMES" && print_error

[ -z "$GSSETRELEASE" ] || GSSKIPADDCHANGELOG=1

for spec in $LISTNAMES
do
	if [ -n "${spec/*spec/}" ] ; then
		print_error
	fi

	set_specdir $spec

	# Set version if needed
	if [ -n "$GSSETVERSION" ] ; then
		CURVER=$(get_version $spec)
		set_version $spec $GSSETVERSION
		if [ "$CURVER" != "$GSSETVERSION" ] ; then
			set_release $spec $GSSETRELEASE
			if [ -n "$GSSETRELEASE" ] ; then
				echo "Set new $GSSETVERSION-$GSSETRELEASE version for $spec"
			else
				echo "Set new $GSSETVERSION version for $spec"
			fi
		else
			echo "Version $GSSETVERSION already was set"
			GSSKIPADDCHANGELOG=1
		fi
	fi

	for nn in "" $LOADLIST
	do
		get_source $spec "Source$nn"

		[ -z "$GETSOURCE" ] && continue
		#[ "$GETSOURCE$nn" = "0" ] && continue
		#test -z "$GETSOURCE" && { echog "Skip Source${nn} from $spec" ; continue ; }

		FTB=`basename "$GETSOURCE"`
		# for get RPMSOURCEDIR
		build_rpms_name $spec

		# TODO: do not use RPMSOURCEDIR for temp. tarballs
		[ -n "$FORCEDOWNLOAD" ] && rm -f "$RPMSOURCEDIR/$FTB"
		#[ -f "$RPMSOURCEDIR/$FTB" ] && { echog "Tarball $FTB already exists in $RPMSOURCEDIR dir, skipping." ; continue ; }

		# TODO: dropout these pushd/popd
		# use pushd/popd due several cd / cd -
		mkdir -p $RPMSOURCEDIR/ && pushd $RPMSOURCEDIR/ >/dev/null || fatal "Can't create/chdir..."

		# Test for eterbuild extensions (will set GETSOURCEURL or GETSOURCESVN)
		get_source_url $spec $nn || get_source_git $spec $nn || get_source_svn $spec $nn

		if ! rhas "$GETSOURCE" ".tar$" ; then
			warning "It is recommended to use .tar tarballs for sources ($FTB now)"
		fi

		if [ -n "${GETSOURCESVN}" ] ; then
			is_gear $SPECDIR || fatal "Source-svn works only with gear repo"

		elif [ -n "${GETSOURCEGIT}" ] ; then
			is_gear $SPECDIR || fatal "Source-git works only with gear repo"

		# TODO: rewrite code to use original file format and temp. download dir
		elif [ -n "${GETSOURCEURL}" ] ; then
			echog "Try to load ${GETSOURCEURL} for $spec"
			download_url "$GETSOURCEURL" || fatal "Can't download $GETSOURCEURL"
			# FIXME: gear-update can use any tarball
			repack_tarball "$(basename "$GETSOURCEURL")" "$FTB"
		else
			rhas "$GETSOURCE" "ps?://" || fatal "$GETSOURCE is not URL"
			download_any_tarball "$GETSOURCE" "$FTB"
		# TODO: fix download single packed file
		#else
		#		download_url "$GETSOURCE"

			# commit tarball
			if [ -n "$GSSETVERSION" ] || [ -n "$FORCEDOWNLOAD" ]; then
				if false && is_gear ; then
					commit_tarball $nn $FTB
				fi
			fi
		fi

		echog "DONE with $FTB"
		popd >/dev/null

	done

	if [ -z "$GSSKIPADDCHANGELOG" ] ; then
		# Write changelog if all done
		CURVER=$(get_version $spec)
		CURREL=$(get_release $spec)
		EGEARME=""
		is_gear && EGEARME=" with rpmgs script"
		add_changelog_helper "- new version ($CURVER)$EGEARME" $spec || echog "Changelog entry for $CURVER-$CURREL already exists"
	fi

	if [ -n "$GSSETVERSION" ] || [ -n "$FORCEDOWNLOAD" ]; then
		if [ -n "${GETSOURCESVN}" ] ; then
			# clone svn repo to current dir
			# FIXME: need to clone in git root dir
			docmd git svn clone $GETSOURCESVN $(get_root_git_dir)
			echo "Run svn rebase from $GETSOURCESVN"
			docmd git svn rebase
		elif [ -n "${GETSOURCEGIT}" ] ; then
			echog "Try to fetch ${GETSOURCEGIT} for $spec"
			#TODO check upstream
			#TODO error if incompatible
			docmd git remote add upstream $GETSOURCEGIT
			docmd git fetch upstream || fatal
			#TODO check tag: v%version or %version
			[ -n "$GSSETVERSION" ] || fatal "Sorry, I don't know new version"
			docmd git merge v$GSSETVERSION || docmd git merge $GSSETVERSION

			# TODO: it is more clean detect that dir
			if [ -d "$(get_root_git_dir)/.gear/tags" ] ; then
				docmd gear-update-tag -a
			fi
			#docmd gammit
			#docmd git commit -m "merge $FTB with rpmgs script"
		elif is_gear ; then
			# TODO: realize above
			commit_tarball || fatal
		fi
	else
		is_gear && echo "Skip tarball committing (run with version or with -f option)."
	fi
done

exit 0

